// Generated by CoffeeScript 1.10.0
(function() {
  var AStarSearch, Absolute, Cell, Corner, CornerAtDiagonalIntersection, EuclideanDistance, Grid, IsTraversable, LineOfSight, ManhattanDistance, Obstacle, OctileDistance, ThetaStarSearch, corner, goal, grid, i, kCornerNormal, kCornerNorthEast, kCornerNorthWest, kCornerSouthEast, kCornerSouthWest, len, myGrid, path, searchie, square, start;

  kCornerNormal = 0;

  kCornerNorthWest = 1;

  kCornerNorthEast = 2;

  kCornerSouthWest = 3;

  kCornerSouthEast = 4;

  myGrid = [[]];

  Corner = (function() {
    function Corner(x, y, cornerType) {
      this.x = x;
      this.y = y;
      this.cornerType = cornerType;
    }

    Corner.North = null;

    Corner.NorthWest = null;

    Corner.NorthEast = null;

    Corner.East = null;

    Corner.West = null;

    Corner.South = null;

    Corner.SouthWest = null;

    Corner.SouthEast = null;

    Corner.fVal = 999999999999999999;

    Corner.gVal = 999999999999999999;

    Corner.hVal = 999999999999999999;

    Corner.Parent = null;

    Corner.prototype.getSuccessors = function() {
      var successors;
      successors = [];
      if (this.North) {
        successors.push(this.North);
      }
      if (this.NorthWest) {
        successors.push(this.NorthWest);
      }
      if (this.NorthEast) {
        successors.push(this.NorthEast);
      }
      if (this.West) {
        successors.push(this.West);
      }
      if (this.East) {
        successors.push(this.East);
      }
      if (this.SouthWest) {
        successors.push(this.SouthWest);
      }
      if (this.SouthEast) {
        successors.push(this.SouthEast);
      }
      if (this.South) {
        successors.push(this.South);
      }
      return successors;
    };

    return Corner;

  })();

  Cell = (function() {
    function Cell(isObstacle) {
      this.isObstacle = isObstacle;
      this.northWest = null;
      this.northEast = null;
      this.southWest = null;
      this.southEast = null;
    }

    return Cell;

  })();

  Obstacle = (function() {
    function Obstacle(x, y) {
      this.gridX = x;
      this.gridY = y;
    }

    return Obstacle;

  })();

  Grid = (function() {
    function Grid(width, height) {
      this.Width = width;
      this.Height = height;
      this.Corners = [];
    }

    Grid.prototype.createEmptyGrid = function() {
      var Row, col, corner, corners, i, j, k, l, len, len1, ref, ref1, ref2, row;
      for (row = i = 0, ref = this.Width; 0 <= ref ? i < ref : i > ref; row = 0 <= ref ? ++i : --i) {
        Row = [];
        for (col = j = 0, ref1 = this.Height; 0 <= ref1 ? j < ref1 : j > ref1; col = 0 <= ref1 ? ++j : --j) {
          Row.push(new Corner(row, col));
        }
        this.Corners.push(Row);
      }
      console.log("Done creating Corners array.");
      ref2 = this.Corners;
      for (k = 0, len = ref2.length; k < len; k++) {
        corners = ref2[k];
        for (l = 0, len1 = corners.length; l < len1; l++) {
          corner = corners[l];
          if (corner.y > 0) {
            corner.North = this.Corners[corner.x][corner.y - 1];
            if (corner.x > 0) {
              corner.NorthWest = this.Corners[corner.x - 1][corner.y - 1];
            }
            if (corner.x < this.Width - 1) {
              corner.NorthEast = this.Corners[corner.x + 1][corner.y - 1];
            }
          }
          if (corner.y < this.Height - 1) {
            corner.South = this.Corners[corner.x][corner.y + 1];
            if (corner.x > 0) {
              corner.SouthWest = this.Corners[corner.x - 1][corner.y + 1];
            }
            if (corner.x < this.Width - 1) {
              corner.SouthEast = this.Corners[corner.x + 1][corner.y + 1];
            }
          }
          if (corner.x > 0) {
            corner.West = this.Corners[corner.x - 1][corner.y];
          }
          if (corner.x < this.Width - 1) {
            corner.East = this.Corners[corner.x + 1][corner.y];
          }
        }
      }
      return console.log("Done linking corners together.");
    };

    Grid.prototype.createGrid = function(Obstacles) {
      var Row, col, corner, corners, i, j, k, l, len, len1, len2, m, obstacle, ref, ref1, ref2, results, row, temp;
      console.log("Beginning to create grid with obstacles");
      for (row = i = 0, ref = this.Width; 0 <= ref ? i < ref : i > ref; row = 0 <= ref ? ++i : --i) {
        Row = [];
        for (col = j = 0, ref1 = this.Height; 0 <= ref1 ? j < ref1 : j > ref1; col = 0 <= ref1 ? ++j : --j) {
          Row.push(new corner(row, col));
        }
        this.Corners.push(Row);
      }
      console.log("Done creating corners array. Now linking the corners.");
      ref2 = this.Corners;
      for (k = 0, len = ref2.length; k < len; k++) {
        corners = ref2[k];
        for (l = 0, len1 = corners.length; l < len1; l++) {
          corner = corners[l];
          if (corner.y > 0) {
            corner.North = this.Corners[corner.x][corner.y - 1];
            if (corner.x > 0) {
              corner.NorthWest = this.Corners[corner.x - 1][corner.y - 1];
            }
            if (corner.x < this.Width - 1) {
              corner.NorthEast = this.Corners[corner.x + 1][corner.y - 1];
            }
          }
          if (corner.y < this.Height - 1) {
            corner.South = this.Corners[corner.x][corner.y + 1];
            if (corner.x > 0) {
              corner.SouthWest = this.Corners[corner.x - 1][corner.y + 1];
            }
            if (corner.x < this.Width - 1) {
              corner.SouthEast = this.Corners[corner.x + 1][corner.y + 1];
            }
          }
          if (corner.x > 0) {
            corner.West = this.Corners[corner.x - 1][corner.y];
          }
          if (corner.x < this.Width - 1) {
            corner.East = this.Corners[corner.x + 1][corner.y];
          }
        }
      }
      results = [];
      for (m = 0, len2 = Obstacles.length; m < len2; m++) {
        obstacle = Obstacles[m];
        console.log(obstacle.x, ",", obstacle.y);
        if (this.Corners[obstacle.x][obstacle.y]) {
          temp = this.Corners[obstacle.x][obstacle.y].SouthEast;
          if (temp) {
            this.Corners[obstacle.x][obstacle.y].SouthEast = null;
            temp.NorthWest = null;
          }
          if (this.Corners[obstacle.x][obstacle.y].NorthEast === null) {
            temp = this.Corners[obstacle.x][obstacle.y].East;
            this.Corners[obstacle.x][obstacle.y].East = null;
            temp.West = null;
          }
          if (obstacle.y > 0) {
            results.push(console.log("Then we can change the North"));
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return Grid;

  })();

  square = function(x) {
    return x * x;
  };

  Absolute = function(a) {
    if (a < 0) {
      a = -a;
    }
    return a;
  };

  EuclideanDistance = function(startcorner, goalcorner) {
    return Math.sqrt((square(startcorner.x - goalcorner.x)) + (square(startcorner.y - goalcorner.y)));
  };

  ManhattanDistance = function(startCorner, goalCorner) {
    return Absolute(goalCorner.y - startCorner.y) + Absolute(goalCorner.x - startCorner.x);
  };

  OctileDistance = function(startCorner, goalCorner) {
    var dx, dy;
    dx = Absolute(startCorner.x - goalCorner.x);
    dy = Absolute(startCorner.y - goalCorner.y);
    return dx + dy + (1 - Math.sqrt(2)) * (Math.min(dx, dy));
  };

  CornerAtDiagonalIntersection = function(x, y) {
    return false;
  };

  IsTraversable = function(x, y) {
    if (myGrid[y][x].isObstacle) {
      return false;
    }
    return true;
  };

  LineOfSight = function(startCorner, goalCorner) {
    var dx, dy, f, sx, sy, x1, x2, x_offset, y1, y2, y_offset;
    x1 = startCorner.x;
    x2 = goalCorner.x;
    y1 = startCorner.y;
    y2 = goalCorner.y;
    dy = y2 - y1;
    dx = x2 - x1;
    if (dx > 0) {
      if (startCorner.cornerType === kCornerNorthWest || startCorner.cornerType === kCornerSouthWest || goalCorner.cornerType === kCornerNorthEast || goalCorner.cornerType === kCornerSouthEast) {
        return false;
      }
      if (dx < 0) {
        if (startCorner.cornerType === kCornerNorthEast || startCorner.cornerType === kCornerSouthEast || goalCorner.cornerType === kCornerNorthWest || goalCorner.cornerType === kCornerSouthWest) {
          return false;
        }
      }
      if (dy > 0) {
        if (startCorner.cornerType === kCornerNorthWest || startCorner.cornerType === kCornerNorthEast || goalCorner.cornerType === kCornerSouthWest || goalCorner.cornerType === kCornerSouthEast) {
          return false;
        }
      }
      if (dy < 0) {
        if (startCorner.cornerType === kCornerSouthWest || startCorner.cornerType === kCornerSouthEast || goalCorner.cornerType === kCornerNorthWest || goalCorner.cornerType === kCornerNorthEast) {
          return false;
        }
      }
    }
    f = 0;
    sy = 0;
    sx = 0;
    x_offset = 0;
    y_offset = 0;
    if (dy < 0) {
      dy = -dy;
      sy = -1;
      y_offset = 0;
    } else {
      sy = 1;
      y_offset = 1;
    }
    if (dx < 0) {
      dx = -dx;
      sx = -1;
      x_offset = 0;
    } else {
      sx = 1;
      x_offset = 1;
    }
    if (dx >= dy) {
      while (x1 !== x2) {
        f = f + dy;
        if (f >= dx) {
          if (!IsTraversable(x1 + x_offset, y1 + y_offset)) {
            return false;
          }
          y1 = y1 + sy;
          f = f - dx;
        }
        if (f !== 0) {
          if (!IsTraversable(x1 + x_offset, y1 + y_offset)) {
            return false;
          }
        }
        if (dy === 0) {
          if (!IsTraversable(x1 + x_offset, y1) && !IsTraversable(x1 + x_offset, y1 + 1)) {
            return false;
          }
        }
        x1 += sx;
        if (f === 0 && x1 !== x2 && CornerAtDiagonalIntersection(x1, y1)) {
          return false;
        }
      }
    } else {
      while (y1 !== y2) {
        f = f + dx;
        if (f >= dy) {
          if (!IsTraversable(x1 + x_offset, y1 + y_offset)) {
            return false;
          }
          x1 = x1 + sx;
          f = f - dy;
        }
        if (f !== 0) {
          if (!IsTraversable(x1 + x_offset, y1 + y_offset)) {
            return false;
          }
        }
        if (dx === 0) {
          if (!IsTraversable(x1, y1 + y_offset) && !IsTraversable(x1 + 1, y1 + y_offset)) {
            return false;
          }
        }
        y1 += sy;
        if (f === 0 && y1 !== y2 && CornerAtDiagonalIntersection(x1, y1)) {
          return false;
        }
      }
    }
    return true;
  };

  AStarSearch = (function() {
    function AStarSearch(heuristic) {
      this.Heuristic = heuristic;
      this.OpenList = [];
      this.ClosedList = [];
    }

    AStarSearch.prototype.smoothPath = function(path) {
      var corner, i, len, smoothedPath;
      smoothedPath = [];
      if (!path) {
        return path;
      }
      smoothedPath.push(path[0]);
      for (i = 0, len = path.length; i < len; i++) {
        corner = path[i];
        if (!(LineOfSight(smoothedPath[smoothedPath.length - 1], corner))) {
          smoothedPath.push(corner);
        }
      }
      smoothedPath.push(path[path.length - 1]);
      return smoothedPath;
    };

    AStarSearch.prototype.addToClosed = function(node) {
      var corner, i, inClosed, inListNode, indexOfNode, indexToRemove, j, k, len, len1, len2, num, ourFval, ref, ref1, ref2, results;
      this.ClosedList.push(node);
      indexToRemove = this.OpenList.indexOf(node);
      if (!(indexToRemove < 0)) {
        this.OpenList.splice(indexToRemove, 1);
      }
      ref = node.getSuccessors();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        corner = ref[i];
        inClosed = false;
        ref1 = this.ClosedList;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          inListNode = ref1[j];
          if (inListNode.x === corner.x) {
            if (inListNode.y === corner.y) {
              inClosed = true;
              break;
            }
          }
        }
        if (inClosed) {
          continue;
        }
        indexOfNode = -1;
        num = 0;
        ref2 = this.OpenList;
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          inListNode = ref2[k];
          if (inListNode.x === corner.x) {
            if (inListNode.y === corner.y) {
              indexOfNode = num;
              break;
            }
          }
          num += 1;
        }
        if (indexOfNode < 0) {
          corner.gVal = node.gVal + 1;
          if (this.Heuristic === "EuclideanDistance") {
            corner.hVal = EuclideanDistance(corner, this.Goalcorner);
          } else if (this.Heuristic === "OctileDistance") {
            corner.hVal = OctileDistance(corner, this.Goalcorner);
          } else {
            corner.hVal = ManhattanDistance(corner, this.Goalcorner);
          }
          corner.fVal = corner.gVal + corner.hVal;
          corner.Parent = node;
          results.push(this.OpenList.push(corner));
        } else {
          ourFval = node.gVal + 1 + EuclideanDistance(corner, this.Goalcorner);
          if (ourFval < this.OpenList[indexOfNode]) {
            this.OpenList.splice(indexOfNode, 1);
            corner.gVal = node.gVal + 1;
            if (this.Heuristic === "EuclideanDistance") {
              corner.hVal = EuclideanDistance(corner, this.Goalcorner);
            } else if (this.Heuristic === "OctileDistance") {
              corner.hVal = OctileDistance(corner, this.Goalcorner);
            } else {
              corner.hVal = ManhattanDistance(corner, this.Goalcorner);
            }
            corner.fVal = corner.gVal + corner.hVal;
            corner.Parent = node;
            results.push(this.OpenList.push(corner));
          } else {
            results.push(void 0);
          }
        }
      }
      return results;
    };

    AStarSearch.prototype.search = function(startcorner, goalcorner) {
      var curr, currNode, i, len, minFval, node, path, reachedGoal, ref;
      this.Goalcorner = goalcorner;
      path = [];
      if (startcorner === goalcorner) {
        console.log("Start is Goal");
        return path;
      }
      startcorner.gVal = 0;
      if (this.Heuristic === "EuclideanDistance") {
        startcorner.hVal = EuclideanDistance(startcorner, goalcorner);
        startcorner.fVal = EuclideanDistance(startcorner, goalcorner);
      } else if (this.Heuristic === "OctileDistance") {
        startcorner.hVal = OctileDistance(startcorner, goalcorner);
        startcorner.fVal = OctileDistance(startcorner, goalcorner);
      } else {
        startcorner.hVal = ManhattanDistance(startcorner, goalcorner);
        startcorner.fVal = ManhattanDistance(startcorner, goalcorner);
      }
      this.addToClosed(startcorner);
      reachedGoal = false;
      while (this.OpenList.length) {
        minFval = 9999999999;
        currNode = null;
        ref = this.OpenList;
        for (i = 0, len = ref.length; i < len; i++) {
          node = ref[i];
          if (node.fVal < minFval) {
            minFval = node.fVal;
            currNode = node;
          }
        }
        if (currNode) {
          this.addToClosed(currNode);
          if (currNode === goalcorner) {
            console.log("Reached goal!");
            reachedGoal = true;
            break;
          }
        } else {
          console.log("Open list empty");
          break;
        }
      }
      if (reachedGoal) {
        curr = goalcorner;
        while (curr !== startcorner) {
          path.push(curr);
          curr = curr.Parent;
        }
        path.push(startcorner);
      }
      path = path.reverse();
      path = this.smoothPath(path);
      return path;
    };

    return AStarSearch;

  })();

  ThetaStarSearch = (function() {
    function ThetaStarSearch(heuristic) {
      this.Heuristic = heuristic;
      this.OpenList = [];
      this.ClosedList = [];
    }

    ThetaStarSearch.prototype.smoothPath = function(path) {
      var corner, i, len, smoothedPath;
      smoothedPath = [];
      if (!path) {
        return path;
      }
      smoothedPath.push(path[0]);
      for (i = 0, len = path.length; i < len; i++) {
        corner = path[i];
        if (!(LineOfSight(smoothedPath[smoothedPath.length - 1], corner))) {
          smoothedPath.push(corner);
        }
      }
      smoothedPath.push(path[path.length - 1]);
      return smoothedPath;
    };

    ThetaStarSearch.prototype.addToClosed = function(node) {
      var corner, i, inClosed, inListNode, indexOfNode, indexToRemove, j, k, len, len1, len2, num, ourFval, ref, ref1, ref2, results;
      this.ClosedList.push(node);
      indexToRemove = this.OpenList.indexOf(node);
      if (!(indexToRemove < 0)) {
        this.OpenList.splice(indexToRemove, 1);
      }
      ref = node.getSuccessors();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        corner = ref[i];
        inClosed = false;
        ref1 = this.ClosedList;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          inListNode = ref1[j];
          if (inListNode.x === corner.x) {
            if (inListNode.y === corner.y) {
              inClosed = true;
              break;
            }
          }
        }
        if (inClosed) {
          continue;
        }
        indexOfNode = -1;
        num = 0;
        ref2 = this.OpenList;
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          inListNode = ref2[k];
          if (inListNode.x === corner.x) {
            if (inListNode.y === corner.y) {
              indexOfNode = num;
              break;
            }
          }
          num += 1;
        }
        if (indexOfNode < 0) {
          corner.gVal = node.gVal + 1;
          if (node.parent) {
            if (LineOfSight(node.parent, corner)) {
              corner.parent = node.parent;
              corner.gVal = corner.parent.gVal + EuclideanDistance(corner.parent, corner);
            }
          }
          if (this.Heuristic === "EuclideanDistance") {
            corner.hVal = EuclideanDistance(corner, this.Goalcorner);
          } else if (this.Heuristic === "OctileDistance") {
            corner.hVal = OctileDistance(corner, this.Goalcorner);
          } else {
            corner.hVal = ManhattanDistance(corner, this.Goalcorner);
          }
          corner.fVal = corner.gVal + corner.hVal;
          corner.Parent = node;
          results.push(this.OpenList.push(corner));
        } else {
          ourFval = node.gVal + 1 + EuclideanDistance(corner, this.Goalcorner);
          if (node.parent) {
            if (LineOfSight(node.parent, corner)) {
              ourFval = node.parent.gVal + EuclideanDistance(node.parent, corner);
            }
          }
          if (ourFval < this.OpenList[indexOfNode]) {
            this.OpenList.splice(indexOfNode, 1);
            corner.gVal = node.gVal + 1;
            if (node.parent) {
              if (LineOfSight(node.parent, corner)) {
                corner.parent = node.parent;
                corner.gVal = corner.parent.gVal + EuclideanDistance(corner.parent, corner);
              }
            }
            if (this.Heuristic === "EuclideanDistance") {
              corner.hVal = EuclideanDistance(corner, this.Goalcorner);
            } else if (this.Heuristic === "OctileDistance") {
              corner.hVal = OctileDistance(corner, this.Goalcorner);
            } else {
              corner.hVal = ManhattanDistance(corner, this.Goalcorner);
            }
            corner.fVal = corner.gVal + corner.hVal;
            corner.Parent = node;
            results.push(this.OpenList.push(corner));
          } else {
            results.push(void 0);
          }
        }
      }
      return results;
    };

    ThetaStarSearch.prototype.search = function(startcorner, goalcorner) {
      var curr, currNode, i, len, minFval, node, path, reachedGoal, ref;
      this.Goalcorner = goalcorner;
      path = [];
      if (startcorner === goalcorner) {
        console.log("Start is Goal");
        return path;
      }
      startcorner.gVal = 0;
      if (this.Heuristic === "EuclideanDistance") {
        startcorner.hVal = EuclideanDistance(startcorner, goalcorner);
        startcorner.fVal = EuclideanDistance(startcorner, goalcorner);
      } else if (this.Heuristic === "OctileDistance") {
        startcorner.hVal = OctileDistance(startcorner, goalcorner);
        startcorner.fVal = OctileDistance(startcorner, goalcorner);
      } else {
        startcorner.hVal = ManhattanDistance(startcorner, goalcorner);
        startcorner.fVal = ManhattanDistance(startcorner, goalcorner);
      }
      this.addToClosed(startcorner);
      reachedGoal = false;
      while (this.OpenList.length) {
        minFval = 9999999999;
        currNode = null;
        ref = this.OpenList;
        for (i = 0, len = ref.length; i < len; i++) {
          node = ref[i];
          if (node.fVal < minFval) {
            minFval = node.fVal;
            currNode = node;
          }
        }
        if (currNode) {
          this.addToClosed(currNode);
          if (currNode === goalcorner) {
            console.log("Reached goal!");
            reachedGoal = true;
            break;
          }
        } else {
          console.log("Open list empty");
          break;
        }
      }
      if (reachedGoal) {
        curr = goalcorner;
        while (curr !== startcorner) {
          path.push(curr);
          curr = curr.Parent;
        }
        path.push(startcorner);
      }
      path = path.reverse();
      path = this.smoothPath(path);
      return path;
    };

    return ThetaStarSearch;

  })();

  grid = new Grid(30, 20);

  grid.createEmptyGrid();

  start = {
    x: 0,
    y: 0
  };

  goal = {
    x: 14,
    y: 11
  };

  searchie = new ThetaStarSearch("OctileDistance");

  path = searchie.search(grid.Corners[4][17], grid.Corners[17][4]);

  console.log("Pathie");

  for (i = 0, len = path.length; i < len; i++) {
    corner = path[i];
    console.log(corner.x, corner.y);
  }

}).call(this);
